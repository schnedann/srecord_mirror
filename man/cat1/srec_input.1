srec_input(1)               General Commands Manual              srec_input(1)



NNAAMMEE
       srec_input - input file specifications

SSYYNNOOPPSSIISS
       ssrreecc__** _f_i_l_e_n_a_m_e [ _f_o_r_m_a_t ]

DDEESSCCRRIIPPTTIIOONN
       This  manual  page  describes  the  input  file  specifications for the
       _s_r_e_c___c_a_t(1), _s_r_e_c___c_m_p(1) and _s_r_e_c___i_n_f_o(1) commands.

       Input files may be qualified in a number of ways: you may specify their
       format  and  you  may  specify filters to apply to them.  An input file
       specification looks like this:
              _f_i_l_e_n_a_m_e [ _f_o_r_m_a_t ][ -ignore-checksums ][ _f_i_l_t_e_r ... ]

       The _f_i_l_e_n_a_m_e may be specified as a file name, or the special  name  "-"
       which is understood to mean the standard input.

   GGrroouuppiinngg wwiitthh PPaarreenntthheesseess
       There  are  some  cases where operator precedence of the filters can be
       ambiguous.  Input specifications may also be enclosed by ((  parentheses
       ))  to  make  grouping  explicit.  Remember that the parentheses must be
       separate words, _i_._e_. surrounded by spaces, and they  will  need  to  be
       quoted to get them past the shell's interpretation of parentheses.

   TThhoossee OOppttiioonn NNaammeess SSuurree AArree LLoonngg
       All  options  may be abbreviated; the abbreviation is documented as the
       upper case letters, all lower case  letters  and  underscores  (_)  are
       optional.  You must use consecutive sequences of optional letters.

       All  options  are  case insensitive, you may type them in upper case or
       lower case or a combination of both, case is not important.

       For example: the arguments "-help", "-HEL" and "-h" are all interpreted
       to  mean the --HHeellpp option.  The argument "-hlp" will not be understood,
       because consecutive optional characters were not supplied.

       Options and other command line arguments may be  mixed  arbitrarily  on
       the command line.

       The  GNU  long option names are understood.  Since all option names for
       _s_r_e_c___i_n_p_u_t are long, this means ignoring the extra  leading  "-".   The
       "----_o_p_t_i_o_n==_v_a_l_u_e" convention is also understood.

   FFiillee FFoorrmmaattss
       The  _f_o_r_m_a_t is specified by the argument _a_f_t_e_r the file name.  The for-
       mat defaults to Motorola S-Record if not specified.  The format  speci-
       fiers are:

       --AAbbssoolluuttee__OObbjjeecctt__MMoodduullee__FFoorrmmaatt
               This option says to use the Intel Absolute Object Module Format
               (AOMF) to read the file.  (See _s_r_e_c___a_o_m_f(5) for  a  description
               of this file format.)

       --AAsscciiii__HHeexx
               This  option says to use the Ascii-Hex format to read the file.
               See _s_r_e_c___a_s_c_i_i___h_e_x(5) for a description of this file format.

       --AAttmmeell__GGeenneerriicc
               This option says to use the Atmel Generic format  to  read  the
               file.  See _s_r_e_c___a_t_m_e_l___g_e_n_e_t_i_c(5) for a description of this file
               format.

       --BBiinnaarryy This option says the file is a raw binary file, and  should  be
               read  literally.   (This option may also be written -Raw.)  See
               _s_r_e_c___b_i_n_a_r_y(5) for more information.

       --BB--RReeccoorrdd
               This option says to  use  the  Freescale  MC68EZ328  Dragonball
               bootstrap    b-record   format   to   read   the   file.    See
               _s_r_e_c___b_r_e_c_o_r_d(5) for a description of this file format.

       --CCOOssmmaacc This option says to use the RCA Cosmac Elf format to  read  the
               file.   See  _s_r_e_c___c_o_s_m_a_c(5) for a description of this file for-
               mat.

       --DDeecc__BBiinnaarryy
               This option says to use the DEC Binary (XXDP)  format  to  read
               the  file.   See  _s_r_e_c___d_e_c___b_i_n_a_r_y(5)  for a description of this
               file format.

       --EElleekkttoorr__MMoonniittoorr5522
               This option says to use the EMON52 format  to  read  the  file.
               See _s_r_e_c___e_m_o_n_5_2(5) for a description of this file format.

       --FFAAIIrrcchhiilldd
               This  option  says  to use the Fairchild Fairbug format to read
               the file.  See _s_r_e_c___f_a_i_r_c_h_i_l_d(5) for a description of this file
               format.

       --FFaasstt__LLooaadd
               This  option says to use the LSI Logic Fast Load format to read
               the file.  See _s_r_e_c___f_a_s_t_l_o_a_d(5) for a description of this  file
               format.

       --FFoorrmmaatttteedd__BBiinnaarryy
               This option says to use the Formatted Binary format to read the
               file.  See _s_r_e_c___f_o_r_m_a_t_t_e_d___b_i_n_a_r_y(5) for a description  of  this
               file format.

       --FFoouurr__PPaacckkeedd__CCooddee
               This  option  says to use the FPC format to read the file.  See
               _s_r_e_c___f_p_c(5) for a description of this file format.

       --GGuueessss  This option may be used to ask the command to guess  the  input
               format.   This is slower than specifying an explicit format, as
               it may open and scan and close the file a number of times.

       --HHEEXX__DDuummpp
               This option says to try to read a hexadecimal dump  file,  more
               or less in the style output by the same option.  This is not an
               exact reverse mapping, because if there are  ASCII  equivalents
               on  the  right hand side, these may be confused for data bytes.
               Also, it doesn't understand white space representing  holes  in
               the data in the line.

       --IIDDTT    This  option  says to the the IDT/sim binary format to read the
               file.  See _s_r_e_c___i_d_t(5) for a description of this file format.

       --IInntteell  This option says to use the Intel hex format to read the  file.
               See _s_r_e_c___i_n_t_e_l(5) for a description of this file format.

       --IINNtteell__HHeeXX__1166
               This  option  says  to  use the Intel hex 16 (INHX16) format to
               read the file.  See _s_r_e_c___i_n_t_e_l_1_6(5) for a description  of  this
               file format.

       --LLOOGGIIssiimm
               This format is read and written by the open source Logisim pro-
               gram.  See _s_r_e_c___l_o_g_i_s_i_m(5) for more informatuion.

       --MMeemmoorryy__IInniittiiaalliizzaattiioonn__FFiillee
               This option says to use the Memory  Initialization  File  (MIF)
               format  by  Altera  to  read  the file.  See _s_r_e_c___m_i_f (5) for a
               description of this file format.

       --MMiippss__FFllaasshh__BBiigg__EEnnddiiaann

       --MMiippss__FFllaasshh__LLiittttllee__EEnnddiiaann
               These options say to use the MIPS Flash file format to read the
               file.   See  _s_r_e_c___m_i_p_s___f_l_a_s_h (5) for a description of this file
               format.

       --MMOOSS__TTeecchhnnoollooggiieess
               This option says to use the Mos Technologies format to read the
               file.  See _s_r_e_c___m_o_s___t_e_c_h(5) for a description of this file for-
               mat.

       --MMoottoorroollaa [ _w_i_d_t_h ]
               This option says to use the Motorola S-Record  format  to  read
               the   file.    (May   be   written  --SS--RReeccoorrdd  as  well.)   See
               _s_r_e_c___m_o_t_o_r_o_l_a(5) for a description of this file format.

               The optional _w_i_d_t_h argument describes the number of bytes which
               form each address multiple.  For normal uses the default of one
               (1) byte is appropriate.  Some systems with  16-bit  or  32-bit
               targets  mutilate  the  addresses in the file; this option will
               correct for that.  Unlike most other parameters, this one  can-
               not be guessed.

       --MMssBBiinn  This option says to use the Windows CE Binary Image Data Format
               to read the file.  See _s_r_e_c___m_s_b_i_n(5) for a description of  this
               file format.

       --NNeeeeddhhaamm__HHeexxaaddeecciimmaall
               This option says to use the Needham Electronics ASCII file for-
               mat to read the file.  See _s_r_e_c___n_e_e_d_h_a_m(5) for a description of
               this file format.

       --OOhhiioo__SScciieennttiiffiicc
               This  option  says  to  use  the  Ohio  Scientific format.  See
               _s_r_e_c___o_s_6_5_v(5) for a description of this file format.

       --PPPPBB    This option says to use the Stag Prom Programmer binary format.
               See _s_r_e_c___p_p_b(5) for a description of this file format.

       --PPPPXX    This  option  says  to use the Stag Prom Programmer hexadecimal
               format.  See _s_r_e_c___p_p_x(5) for a description of this file format.

       --SSIIGGnneettiiccss
               This  option  says  to   use   the   Signetics   format.    See
               _s_r_e_c___s_p_a_s_m(5) for a description of this file format.

       --SSPPAAssmm  This is a synonym for the --SSPPAAssmm__BBiigg__EEnnddiiaann option.

       --SSPPAAssmm__BBiigg__EEnnddiiaann
               This option says to use the SPASM assembler output format (com-
               monly used  by  PIC  programmers).   See  _s_r_e_c___s_p_a_s_m(5)  for  a
               description of this file format.

       --SSPPAAssmm__LLiittttllee__EEnnddiiaann
               This  option says to use the SPASM assembler output format, but
               with the data the other way around.

       --SSTTeewwiiee This option says to use the Stewie binary format  to  read  the
               file.   See  _s_r_e_c___s_t_e_w_i_e(5) for a description of this file for-
               mat.

       --TTeekkttrroonniixx
               This option says to use the Tektronix hex format  to  read  the
               file.   See  _s_r_e_c___t_e_k_t_r_o_n_i_x(5)  for  a description of this file
               format.

       --TTeekkttrroonniixx__EExxtteennddeedd
               This option says to use the Tektronix extended  hex  format  to
               read  the  file.  See _s_r_e_c___t_e_k_t_r_o_n_i_x___e_x_t_e_n_d_e_d(5) for a descrip-
               tion of this file format.

       --TTeexxaass__IInnssttrruummeennttss__TTaaggggeedd
               This option says to use the Texas Instruments Tagged format  to
               read the file.  See _s_r_e_c___t_i___t_a_g_g_e_d(5) for a description of this
               file format.

       --TTeexxaass__IInnssttrruummeennttss__TTaaggggeedd__1166
               This option says to use the Texas Instruments SDSMAC 320 format
               to  read  the file.  See _s_r_e_c___t_i___t_a_g_g_e_d___1_6(5) for a description
               of this file format.

       --TTeexxaass__IInnssttrruummeennttss__TTeeXXTT
               This option says to use the Texas Instruments TXT (MSP430) for-
               mat  to read the file.  See _s_r_e_c___t_i___t_x_t(5) for a description of
               this file format.

       --TTRRSS8800  This option says to use the Radio Shack TRS-80 object file for-
               mat  to  read the file.  See _s_r_e_c___t_r_s_8_0(5) for a description of
               this file format.

       --VVMMeemm   This option says to use the Verilog VMEM  format  to  read  the
               file.  See _s_r_e_c___v_m_e_m(5) for a description of this file format.

       --WWIILLssoonn This  option  says  to  use the wilson format to read the file.
               See _s_r_e_c___w_i_l_s_o_n(5) for a description of this file format.

   IIggnnoorree CChheecckkssuummss
       The --IIGGnnoorree--CChheecckkssuummss option may be used to disable checksum validation
       of  input  files,  for those formats which have checksums at all.  Note
       that the checksum values are still read in and parsed (so it  is  still
       an  error  if they are missing) but their values are not checked.  Used
       after an input file name, the option affects that file alone; used any-
       where else on the command line, it applies to all following files.

       --rreedduunnddaanntt--bbyytteess==_v_a_l_u_e
               Use  this  option  to permit a file to contain redundant values
               for some memory locations.  The default is for  this  condition
               to be a warning.

               ignore
                   No  warning or error is issued whena redundant settings are
                   detected.

               warning
                   A warning is issued when a redundant settings are observed,
                   the warning includes the problematic address.

               error
                   A  fatal  error  is  issued  when  a redundant settings are
                   observed, the fatal error message includes the  problematic
                   address and byte value.

       --ccoonnttrraaddiiccttoorryy--bbyytteess==_v_a_l_u_e
               Use  this option to permit a file to contain contradictory val-
               ues for some memory locations.  The last value in the  input(s)
               will  be used.  The default is for this condition to be a fatal
               error.

               ignore
                   No warning or error is issued when contradictory setting is
                   detected.

               warning
                   A  warning  is  issued  when  a  vontradictory settings are
                   observed, the warning includes the problematic address, and
                   values.

               error
                   A  fatal  error  is  issued when contradictory settings are
                   observed, the fatal error message includes the  problematic
                   address and byte values.

   GGeenneerraattoorrss
       It  is also possible to generate data, rather than read it from a file.
       You may use a generator anywhere you could use a file.  An input gener-
       ator specification looks like this:

         --GGEENNeerraattee _a_d_d_r_e_s_s_-_r_a_n_g_e --_d_a_t_a_-_s_o_u_r_c_e

       The --_d_a_t_a_-_s_o_u_r_c_e may be one of the following:

       --CCOONNSSTTaanntt _b_y_t_e_-_v_a_l_u_e
               This  generator  manufactures data with the given byte value of
               the the given address range.  It is an error if the  byte-value
               is not in the range 0..255.

               For  example,  to  fill memory addresses 100..199 with newlines
               (0x0A), you could use a command like

                 srec_cat -generate 100 200 -constant 10 -o newlines.srec

               This can, of course, be combined with data from files.

       --RREEPPeeaatt__DDaattaa _b_y_t_e_-_v_a_l_u_e...
               This generator manufactures data with  the  given  byte  values
               repeating  over the the given address range.  It is an error if
               any of the the byte-values are not in the range 0..255.

               For example, to create a data region  with  0xDE  in  the  even
               bytes and 0xAD in the odd bytes, use a generator like this:

                 srec_cat -generate 0x1000 0x2000 -repeat-data 0xDE 0xAD

               The  repeat boundaries are aligned with the base of the address
               range, modulo the number of bytes.

       --RREEPPeeaatt__SSttrriinngg _t_e_x_t
               This generator is almost identical to -repeat-data except  that
               the data to be repeated is the text of the given string.

               For  example,  to  fill  the holes in an EPROM image _e_p_r_o_m_._s_r_e_c
               with the text "Copyright (C) 1812 Tchaikovsky", combine a  gen-
               erator and an -exclude filter, such as the command

               If  you need to inject binary data into the string (e.g. a ter-
               minating NUL character), use the URL encoding that uses %  fol-
               lowed  by  two  hexadeimal characters.  For example a backspace
               would be encoded as "%08".

                 srec_cat eprom.srec \
                     -generate 0 0x100000 \
                         -repeat-string 'Copyright (C) 1812 Tchaikovsky. ' \
                         -exclude -within eprom.srec \
                     -o eprom.filled.srec

               The thing to note  is  that  we  have  two  data  sources:  the
               _e_p_r_o_m_._s_r_e_c file, and generated data over an address range which
               covers first megabyte of memory but excluding areas covered  by
               the _e_p_r_o_m_._s_r_e_c data.

       --CCOONNSSTTaanntt__LLiittttllee__EEnnddiiaann _v_a_l_u_e _w_i_d_t_h
               This  generator manufactures data with the given numeric value,
               of a given byte width, in little-endian byte order.  It  is  an
               error  if  the  given  value  does  not fit into the given byte
               width.  It will repeat over and over within the  address  range
               range.

               For  example, to insert a subversion commit number into 4 bytes
               at 0x0008..0x000B you would use a command like

                 srec_cat -generate 8 12 -constant-l-e $VERSION 4 \
                     -o version.srec

               This generator is a convenience wrapper around the --RREEPPeeaatt__DDaattaa
               generator.   It  can,  of  course,  be  combined with data from
               files.

       --CCOONNSSTTaanntt__BBiigg__EEnnddiiaann _v_a_l_u_e _w_i_d_t_h
               As above, but using big-endian byte ordering.

       Anything else will result in an error.

   IInnppuutt FFiilltteerrss
       You may specify zero or  more  _f_i_l_t_e_r_s  to  be  applied.   Filters  are
       applied in the order the user specifies.

       --AAddlleerr__1166__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s
               This filter may be used to insert an "Adler" 16-bit checksum of
               the data into the  data.   Two  bytes,  big-endian  order,  are
               inserted  at  the  address  given.  Holes in the input data are
               ignored.  Bytes are processed in ascending address  order  (_n_o_t
               in the order they appear in the input).

               NNoottee::  If you have holes in your data, you will get a different
               Adler checksum than if there were no holes.  This is  important
               because  the  in-memory  EPROM  image will not have holes.  You
               almost always want to use the --ffiillll filter before  any  of  the
               Adler checksum filters.  You will receive a warning if the data
               presented for Adler checksum has holes.

               You should also be aware that the lower  and  upper  bounds  of
               your  data may not be the same as the lower and upper bounds of
               your EPROM.  This is another reason to use  the  --ffiillll  filter,
               because  it  will  establish  the  data  across  the full EPROM
               address range.

               http://en.wikipedia.org/wiki/Adler-32

       --AAddlleerr__1166__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s
               This filter may be used to insert an Adler 16-bit  checksum  of
               the data into the data.  Two bytes, in little-endian order, are
               inserted at the address given.  Holes in  the  input  data  are
               ignored.   Bytes  are processed in ascending address order (_n_o_t
               in the order they appear in the input).

               NNoottee:: If you have holes in your data, you will get a  different
               Adler  checksum than if there were no holes.  This is important
               because the in-memory EPROM image will  not  have  holes.   You
               almost  always  want  to use the --ffiillll filter before any of the
               Adler filters.  You will receive a warning  if  the  data  pre-
               sented for Adler checksum has holes.

               You  should  also  be  aware that the lower and upper bounds of
               your data may not be the same as the lower and upper bounds  of
               your  EPROM.   This  is another reason to use the --ffiillll filter,
               because it will  establish  the  data  across  the  full  EPROM
               address range.

               http://en.wikipedia.org/wiki/Adler-32

       --AAddlleerr__3322__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s
               This  filter  may  be used to insert a Adler 32-bit checksum of
               the data into the data.   Four  bytes,  big-endian  order,  are
               inserted  at  the  address  given.  Holes in the input data are
               ignored.  Bytes are processed in ascending address  order  (_n_o_t
               in the order they appear in the input).

               NNoottee::  If you have holes in your data, you will get a different
               Adler checksum than if there were no holes.  This is  important
               because  the  in-memory  EPROM  image will not have holes.  You
               almost always want to use the --ffiillll filter before  any  of  the
               Adler checksum filters.  You will receive a warning if the data
               presented for Adler checksum has holes.

               You should also be aware that the lower  and  upper  bounds  of
               your  data may not be the same as the lower and upper bounds of
               your EPROM.  This is another reason to use  the  --ffiillll  filter,
               because  it  will  establish  the  data  across  the full EPROM
               address range.

               http://en.wikipedia.org/wiki/Adler-32

       --AAddlleerr__3322__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s
               This filter may be used to insert a Adler  32-bit  checksum  of
               the  data  into  the data.  Four bytes, in little-endian order,
               are inserted at the address given.  Holes in the input data are
               ignored.   Bytes  are processed in ascending address order (_n_o_t
               in the order they appear in the input).

               NNoottee:: If you have holes in your data, you will get a  different
               Adler  checksum than if there were no holes.  This is important
               because the in-memory EPROM image will  not  have  holes.   You
               almost  always  want  to use the --ffiillll filter before any of the
               Adler checksum filters.  You will receive a warning if the data
               presented for Adler checksum has holes.

               You  should  also  be  aware that the lower and upper bounds of
               your data may not be the same as the lower and upper bounds  of
               your  EPROM.   This  is another reason to use the --ffiillll filter,
               because it will  establish  the  data  across  the  full  EPROM
               address range.

               http://en.wikipedia.org/wiki/Adler-32

       --AANNDD _v_a_l_u_e
               This  filter  may be used to bit-wise AND a _v_a_l_u_e to every data
               byte.  This is useful if you need to clear bits.  Only existing
               data is altered, no holes are filled.

       --BBiitt__RReevveerrssee [ _w_i_d_t_h ]
               This  filter  may  be  used to reverse the order of the bits in
               each data byte.  By specifying a width (in bytes) it is  possi-
               ble to reverse the order multi-byte values; this is implemented
               using the byte-swap filter.

       --BByyttee__SSwwaapp [ _w_i_d_t_h ]
               This filter may be used to swap pairs of odd  and  even  bytes.
               By  specifying a width (in bytes) it is possible to reverse the
               order of 4 and 8 bytes, the default is  2  bytes.   (Widths  in
               excess  of 8 are assumed to be number of bits.)  It is not pos-
               sible to swap non-power-of-two addresses.  To change the align-
               ment, use the offset filter before and after.

       --CChheecckkssuumm__BBiittNNoott__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This filter may be used to insert the one's complement checksum
               of the data into the data, most significant  byte  first.   The
               data  is  literally  summed; if there are duplicate bytes, this
               will produce an incorrect result, if there are holes,  it  will
               be as if they were filled with zeros.  If the data already con-
               tains bytes at the  checksum  location,  you  need  to  use  an
               exclude  filter,  or  this  will  generate errors.  You need to
               apply and crop or fill filters before this filter.   The  value
               will be written with the most significant byte first.  The num-
               ber of bytes of resulting checksum defaults to  4.   The  width
               (the width in bytes of the values being summed) defaults to 1.

       --CChheecckkssuumm__BBiittNNoott__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This filter may be used to insert the one's complement (bitnot)
               checksum of the data into  the  data,  least  significant  byte
               first.  Otherwise similar to the above.

       --CChheecckkssuumm__NNeeggaattiivvee__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This  filter  may be used to insert the two's complement (nega-
               tive) checksum of the data into the data.  Otherwise similar to
               the above.

       --CChheecckkssuumm__NNeeggaattiivvee__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This  filter  may be used to insert the two's complement (nega-
               tive) checksum of the data into the data.  Otherwise similar to
               the above.

       --CChheecckkssuumm__PPoossiittiivvee__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This  filter  may  be used to insert the simple checksum of the
               data into the data.  Otherwise similar to the above.

       --CChheecckkssuumm__PPoossiittiivvee__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This filter may be used to insert the simple  checksum  of  the
               data into the data.  Otherwise similar to the above.

       --CCRRCC1166__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _m_o_d_i_f_i_e_r... ]
               This  filter  may be used to insert an industry standard 16-bit
               CRC checksum of the data into the data.  Two bytes,  big-endian
               order,  are  inserted at the address given.  Holes in the input
               data are ignored.  Bytes are  processed  in  ascending  address
               order (_n_o_t in the order they appear in the input).

               The following additional modifiers are understood:

               _n_u_m_b_e_r  Set the polynomial to be used to the given number.

               --PPOOLLYYnnoommiiaall _n_a_m_e
                       This option may be used to set the CRC polynomial to be
                       used, by name.  The known names include:

                              ibm       0x8005
                              ansi      0x8005
                              ccitt     0x1021
                              t10-dif   0x8bb7
                              dnp       0x3d65
                              dect      0x0589

                       See          http://en.wikipedia.org/wiki/Cyclic_redun-
                       dancy_check for a table of names and values.

               --MMoosstt__TToo__LLeeaasstt
                       The CRC calculation is performed with the most signifi-
                       cant bit in each byte processed first,  and  then  pro-
                       ceeding towards the least significant bit.  This is the
                       default.

               --LLeeaasstt__TToo__MMoosstt
                       The CRC calculation is performed with the least signif-
                       icant  bit  in each byte processed first, and then pro-
                       ceeding towards the most significant bit.

               --CCCCIITTTT  The CCITT calculation is performed.  The  initial  seed
                       is 0xFFFF.  This is the default.

               --XXMMOODDEEMM The  alternate  XMODEM  calculation  is performed.  The
                       initial seed is 0x0000.

               --BBRROOKKEENN A common-but-broken calculation is performed (see  note
                       2 below).  The initial seed is 0x84CF.

               --AAUUGGmmeenntt
                       The CRC is augmented by sixteen zero bits at the end of
                       the calculation.  This is the default.

               --NNoo--AAUUGGmmeenntt
                       The CRC is not augmented at the end of the calculation.
                       This  is less standard conforming, but some implementa-
                       tions do this.

               NNoottee:: If you have holes in your data, you will get a  different
               CRC than if there were no holes.  This is important because the
               in-memory EPROM image will not have holes.  You  almost  always
               want  to  use  the  --ffiillll filter before any of the CRC filters.
               You will receive a warning if the data presented  for  CRC  has
               holes.

               You  should  also  be  aware that the lower and upper bounds of
               your data may not be the same as the lower and upper bounds  of
               your  EPROM.   This  is another reason to use the --ffiillll filter,
               because it will  establish  the  data  across  the  full  EPROM
               address range.

               NNoottee 22:: there are a great many CRC16 implementations out there,
               see  http://www.joegeluso.com/software/articles/ccitt.htm  (now
               gone,     reproduced     at     http://srecord.sourceforge.net-
               /crc16-ccitt.html) and "A painless guide to CRC error detection
               algorithms"  http://www.repairfaq.org/filipg/LINK/F_crc_v3.html
               for more information.  If  all  else  fails,  SRecord  is  open
               source  software:  read  the  SRecord  source  code.  The CRC16
               source code (found in the srecord/crc16.cc file of the  distri-
               bution tarball) has a great many explanatory comments.

               Please  try all twelve combinations of the above options before
               reporting a bug in the CRC16 calculation.

       --CCRRCC1166__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _m_o_d_i_f_i_e_r... ]
               The same as the --CCRRCC1166__BBiigg__EEnnddiiaann  filter,  except  in  little-
               endian byte order.

       --CCRRCC3322__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _m_o_d_i_f_i_e_r... ]
               This  filter  may be used to insert an industry standard 32-bit
               CRC checksum of the data into the data.  Four bytes, big-endian
               order,  are  inserted at the address given.  Holes in the input
               data are ignored.  Bytes are  processed  in  ascending  address
               order  (_n_o_t  in  the order they appear in the input).  See also
               the note about holes, above.

               The following additional modifiers are understood:

               --CCCCIITTTT  The CCITT calculation is performed.  The  initial  seed
                       is all one bits.  This is the default.

               --XXMMOODDEEMM An  alternate  XMODEM-style  calculation  is performed.
                       The initial seed is all zero bits.

       --CCRRCC3322__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s
               The same as the --CCRRCC3322__BBiigg__EEnnddiiaann  filter,  except  in  little-
               endian byte order.

       --CCrroopp _a_d_d_r_e_s_s_-_r_a_n_g_e
               This  filter may be used to isolate a section of data, and dis-
               card the rest.

       --EExxcclluuddee _a_d_d_r_e_s_s_-_r_a_n_g_e
               This filter may be used to exclude a section of data, and  keep
               the rest.  The is the logical complement of the --CCrroopp filter.

       --EExxcclluussiivvee__LLeennggtthh__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               The  same  as  the  --LLeennggtthh__BBiigg__EEnnddiiaann  filter, except that the
               result does nnoott include the length itself.

       --EExxcclluussiivvee__LLeennggtthh__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               The same as the --LLeennggtthh__LLiittttllee__EEnnddiiaann filter, except  that  the
               result does nnoott include the length itself.

       --EExxcclluussiivvee__MMAAXXiimmuumm__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               The  same  as  the  --MMAAXXiimmuumm__BBiigg__EEnnddiiaann filter, except that the
               result does nnoott include the maximum itself.

       --EExxcclluussiivvee__MMAAXXiimmuumm__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               The same as the --MMAAXXiimmuumm__LLiittttllee__EEnnddiiaann filter, except that  the
               result does nnoott include the maximum itself.

       --EExxcclluussiivvee__MMIINNiimmuumm__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               The  same  as  the  --MMIINNiimmuumm__BBiigg__EEnnddiiaann filter, except that the
               result does nnoott include the minimum itself.

       --EExxcclluussiivvee__MMIINNiimmuumm__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               The same as the --MMIINNiimmuumm__LLiittttllee__EEnnddiiaann filter, except that  the
               result does nnoott include the minimum itself.

       --eeXXcclluussiivvee--OORR _v_a_l_u_e
               This  filter  may be used to bit-wise XOR a _v_a_l_u_e to every data
               byte.  This is useful if you need to invert bits.  Only  exist-
               ing data is altered, no holes are filled.

       --FFiillll _v_a_l_u_e _a_d_d_r_e_s_s_-_r_a_n_g_e
               This filter may be used to fill any gaps in the data with bytes
               equal to _v_a_l_u_e.  The fill will only occur in the address  range
               given.

       --FFlleettcchheerr__1166__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _s_u_m_1 _s_u_m_2 [ _a_n_s_w_e_r ]]
               This  filter  may be used to insert an Fletcher 16-bit checksum
               of the data into the data.  Two bytes,  big-endian  order,  are
               inserted  at  the  address  given.  Holes in the input data are
               ignored.  Bytes are processed in ascending address  order  (_n_o_t
               in the order they appear in the input).

               NNoottee::  If you have holes in your data, you will get a different
               Fletcher checksum than if there were no holes.  This is  impor-
               tant  because  the  in-memory  EPROM image will not have holes.
               You almost always want to use the --ffiillll filter  before  any  of
               the  Fletcher  checksum filters.  You will receive a warning if
               the data presented for Fletcher checksum has holes.

               You should also be aware that the lower  and  upper  bounds  of
               your  data may not be the same as the lower and upper bounds of
               your EPROM.  This is another reason to use  the  --ffiillll  filter,
               because  it  will  establish  the  data  across  the full EPROM
               address range.

               http://en.wikipedia.org/wiki/Fletcher%27s_checksum

               It is possible to select seed values for _s_u_m_1 and _s_u_m_2  in  the
               algorithm,  by  adding  seed  values on the command line.  They
               each default to 0xFF if not  explicitly  stated.   The  default
               values  (0)  means  that  an empty EPROM (all 0x00 or all 0xFF)
               will sum to zero; by changing the seeds, an  empty  EPROM  will
               always fail.

               The third optional argument is the desired sum, when the check-
               sum itself is summed.  A common value is 0x0000, placed in  the
               last two bytes of an EPROM, so that the Fletcher 16 checksum of
               the EPROM is exactly 0x0000.   No  manipulation  of  the  final
               value is performed if this value if not specified.

       --FFlleettcchheerr__1166__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s
               This  filter  may be used to insert an Fletcher 16-bit checksum
               of the data into the data.  Two bytes, in little-endian  order,
               are inserted at the address given.  Holes in the input data are
               ignored.  Bytes are processed in ascending address  order  (_n_o_t
               in the order they appear in the input).

               NNoottee::  If you have holes in your data, you will get a different
               Fletcher checksum than if there were no holes.  This is  impor-
               tant  because  the  in-memory  EPROM image will not have holes.
               You almost always want to use the --ffiillll filter  before  any  of
               the  Fletcher  filters.  You will receive a warning if the data
               presented for Fletcher checksum has holes.

               You should also be aware that the lower  and  upper  bounds  of
               your  data may not be the same as the lower and upper bounds of
               your EPROM.  This is another reason to use  the  --ffiillll  filter,
               because  it  will  establish  the  data  across  the full EPROM
               address range.

               http://en.wikipedia.org/wiki/Fletcher%27s_checksum

       --FFlleettcchheerr__3322__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s
               This filter may be used to insert a Fletcher 32-bit checksum of
               the  data  into  the  data.   Four bytes, big-endian order, are
               inserted at the address given.  Holes in  the  input  data  are
               ignored.   Bytes  are processed in ascending address order (_n_o_t
               in the order they appear in the input).

               NNoottee:: If you have holes in your data, you will get a  different
               Fletcher  checksum than if there were no holes.  This is impor-
               tant because the in-memory EPROM image  will  not  have  holes.
               You  almost  always  want to use the --ffiillll filter before any of
               the Fletcher checksum filters.  You will receive a  warning  if
               the data presented for Fletcher checksum has holes.

               You  should  also  be  aware that the lower and upper bounds of
               your data may not be the same as the lower and upper bounds  of
               your  EPROM.   This  is another reason to use the --ffiillll filter,
               because it will  establish  the  data  across  the  full  EPROM
               address range.

               http://en.wikipedia.org/wiki/Fletcher%27s_checksum

       --FFlleettcchheerr__3322__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s
               This filter may be used to insert a Fletcher 32-bit checksum of
               the data into the data.  Four bytes,  in  little-endian  order,
               are inserted at the address given.  Holes in the input data are
               ignored.  Bytes are processed in ascending address  order  (_n_o_t
               in the order they appear in the input).

               NNoottee::  If you have holes in your data, you will get a different
               Fletcher checksum than if there were no holes.  This is  impor-
               tant  because  the  in-memory  EPROM image will not have holes.
               You almost always want to use the --ffiillll filter  before  any  of
               the  Fletcher  checksum filters.  You will receive a warning if
               the data presented for Fletcher checksum has holes.

               You should also be aware that the lower  and  upper  bounds  of
               your  data may not be the same as the lower and upper bounds of
               your EPROM.  This is another reason to use  the  --ffiillll  filter,
               because  it  will  establish  the  data  across  the full EPROM
               address range.

               http://en.wikipedia.org/wiki/Fletcher%27s_checksum

       --LLeennggtthh__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               This filter may be used to insert the length of the data  (high
               water minus low water) into the data.  This includes the length
               itself.  If the data already contains bytes at the length loca-
               tion,  you need to use an exclude filter, or this will generate
               errors.  The value will be written with  the  most  significant
               byte  first.   The  number  of  bytes defaults to 4.  The width
               defaults to 1, and is divided into the actual length, thus  you
               can insert the width in units of words (2) or longs (4).

       --LLeennggtthh__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s [ _w_i_d_t_h ]]
               The  same  as  the  --LLeennggtthh__BBiigg__EEnnddiiaann filter, except the value
               will be written with the least significant byte first.

       --MMAAXXiimmuumm__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               This filter may be used to insert the maximum  address  of  the
               data (high water
                + 1) into the data.  This includes the maximum itself.  If the
               data already contains bytes at the given address, you  need  to
               use an exclude filter, or this will generate errors.  The value
               will be written with the most significant byte first.  The num-
               ber of bytes defaults to 4.

       --MMAAXXiimmuumm__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               The  same  as  the --MMAAXXiimmuumm__BBiigg__EEnnddiiaann filter, except the value
               will be written with the least significant byte first.

       --MMeessssaaggee__DDiiggeesstt__55 _a_d_d_r_e_s_s
               This filter may be used to insert a 16 byte MD5 hash  into  the
               data, at the address given.

       --MMIINNiimmuumm__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               This  filter  may  be used to insert the minimum address of the
               data (low water) into the  data.   This  includes  the  minimum
               itself.   If  the  data  already  contains  bytes  at the given
               address, you need to use an exclude filter, or this will gener-
               ate  errors.   The value will be written with the most signifi-
               cant byte first.  The number of bytes defaults to 4.

       --MMIINNiimmuumm__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s [ _n_b_y_t_e_s ]
               The same as the --MMIINNiimmuumm__BBiigg__EEnnddiiaann filter,  except  the  value
               will be written with the least significant byte first.

       --NNOOTT    This filter may be used to bit-wise NOT the value of every data
               byte.  This is useful if you need to  invert  the  data.   Only
               existing data is altered, no holes are filled.

       --OOFFffsseett _n_b_y_t_e_s
               This  filter  may  be used to offset the addresses by the given
               number of bytes.  No data is  lost,  the  addresses  will  wrap
               around  in 32 bits, if necessary.  You may use negative numbers
               for the offset, if you wish to move data lower in memory.

               Please note: the execution start address is a different concept
               than  the first address in memory of your data.  If you want to
               change where your monitor will start executing, use the --eexxeeccuu--
               ttiioonn--ssttaarrtt--aaddddrreessss option (_s_r_e_c___c_a_t(1) only).

       --OORR _v_a_l_u_e
               This  filter  may  be used to bit-wise OR a _v_a_l_u_e to every data
               byte.  This is useful if you need to set bits.   Only  existing
               data is altered, no holes are filled.

       --RRaannddoomm__FFiillll _a_d_d_r_e_s_s_-_r_a_n_g_e
               This  filter may be used to fill any gaps in the data with ran-
               dom bytes.  The fill will  only  occur  in  the  address  range
               given.

       --RRiippee__MMeessssaaggee__DDiiggeesstt__116600 _a_d_d_r_e_s_s
               This filter may be used to insert an RMD160 hash into the data.

       --SSeeccuurree__HHaasshh__AAllggoorriitthhmm__11 _a_d_d_r_e_s_s
               This  filter may be used to insert a 20 byte SHA1 hash into the
               data, at the address given.

       --SSeeccuurree__HHaasshh__AAllggoorriitthhmm__222244 _a_d_d_r_e_s_s
               This filter may be used to insert a 28 byte  SHA224  hash  into
               the  data,  at the address given.  See Change Notice 1 for FIPS
               180-2 for the specification.

       --SSeeccuurree__HHaasshh__AAllggoorriitthhmm__225566 _a_d_d_r_e_s_s
               This filter may be used to insert a 32 byte  SHA256  hash  into
               the  data, at the address given.  See FIPS 180-2 for the speci-
               fication.

       --SSeeccuurree__HHaasshh__AAllggoorriitthhmm__338844 _a_d_d_r_e_s_s
               This filter may be used to insert a 48 byte  SHA384  hash  into
               the  data, at the address given.  See FIPS 180-2 for the speci-
               fication.

       --SSeeccuurree__HHaasshh__AAllggoorriitthhmm__551122 _a_d_d_r_e_s_s
               This filter may be used to insert a 64 byte  SHA512  hash  into
               the  data, at the address given.  See FIPS 180-2 for the speci-
               fication.

       --SSPPlliitt _m_u_l_t_i_p_l_e [ _o_f_f_s_e_t [ _w_i_d_t_h ] ]
               This filter may be used to split the input into a subset of the
               data,  and  compress  the address range so as to leave no gaps.
               This useful for wide data buses and memory striping.  The  _m_u_l_-
               _t_i_p_l_e  is  the  bytes multiple to split over, the _o_f_f_s_e_t is the
               byte offset into this range (defaults to 0), the _w_i_d_t_h  is  the
               number of bytes to extract (defaults to 1) within the multiple.
               In order to leave no gaps, the output addresses  are  (_w_i_d_t_h  /
               _m_u_l_t_i_p_l_e) times the input addresses.

       --SSTTMM3322 _a_d_d_r_e_s_s
               This is a synonym for the --SSTTMM3322__LLiittttllee__EEnnddiiaann filter.

       --SSTTMM3322__LLiittttllee__EEnnddiiaann _a_d_d_r_e_s_s

       --SSTTMM3322__BBiigg__EEnnddiiaann _a_d_d_r_e_s_s
               These filters many be use to generate the CRC used by the hard-
               ware CRC unit on the STM32 series of ARM MPUs.   The  algorithm
               used  by the STM32 hardware unit is just a CRC32 with a differ-
               ent polynomial and word-fed instead of byte-fed.

               The _a_d_d_r_e_s_s is where to place the 4-byte STM32 CRC.

               The CRC used is documented in  "RM0041,  STM32F100xx  reference
               manual",  page 46, chapter "CRC Calculation Unit", which can be
               found at
               http://www.st.com/internet/mcu/product/216844.jsp

       --TTIIGGeerr _a_d_d_r_e_s_s
               This filter may be used to insert a 24 byte TIGER/192 hash into
               the data at the address given.

       --UUnnFFiillll _v_a_l_u_e [ _m_i_n_-_r_u_n_-_l_e_n_g_t_h ]
               This  filter  may be used to create gaps in the data with bytes
               equal to _v_a_l_u_e.  You can think of it as reversing  the  effects
               of  the --FFiillll filter.  The gaps will only be created if the are
               at least _m_i_n_-_r_u_n_-_l_e_n_g_t_h bytes in a row (defaults to 1).

       --UUnn__SSPPlliitt _m_u_l_t_i_p_l_e [ _o_f_f_s_e_t [ _w_i_d_t_h ] ]
               This filter may be used to reverse the  effects  of  the  split
               filter.   The  arguments  are identical.  Note that the address
               range is expanded  (_m_u_l_t_i_p_l_e  /  _w_i_d_t_h)  times,  leaving  holes
               between the stripes.

       --WWHHIIrrllppooooll _a_d_d_r_e_s_s
               This filter may be used to insert a 64 byte WHIRLPOOL hash into
               the data, at the address given.

   AAddddrreessss RRaannggeess
       There are eight ways to specify an address range:

       _m_i_n_i_m_u_m _m_a_x_i_m_u_m
               If you specify two number on the command line  (decimal,  octal
               and  hexadecimal  are understood, using the C conventions) this
               is an explicit address range.  The minimum  is  inclusive,  the
               maximum  is exclusive (one more than the last address).  If the
               maximum is given as zero then the range extends to the  end  of
               the address space.

       --WWiitthhiinn _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n
               This says to use the specified input file as a mask.  The range
               includes all the places the specified input has data, and holes
               where it has holes.  The input specification need not be just a
               file name, it may be anything any other input specification can
               be.

               See  also  the --oovveerr option for a discussion on operator prece-
               dence.

       --OOVVEERR _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n
               This says to use the specified input file as a mask.  The range
               extends  from  the  minimum  to the maximum address used by the
               input, without any holes, even if the  input  has  holes.   The
               input  specification  need  not  be just a file name, it may be
               anything any other input specification can be.

               You may need to enclose _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n in  parentheses  to
               make  sure  it can't misinterpret which arguments go with which
               input specification.  This is  particularly  important  when  a
               filter is to follow.  For example
                      _f_i_l_e_n_a_m_e -fill 0 -over _f_i_l_e_n_a_m_e_2 -swap-bytes
               groups as
                      _f_i_l_e_n_a_m_e -fill 0 -over '(' _f_i_l_e_n_a_m_e_2 -swap-bytes ')'
               when what you actually wanted was
                      '(' _f_i_l_e_n_a_m_e -fill 0 -over _f_i_l_e_n_a_m_e_2 ')' -swap-bytes
               The  command  line  expression parsing tends to be "greedy" (or
               right associative) rather than conservative (or  left  associa-
               tive).

       _a_d_d_r_e_s_s_-_r_a_n_g_e --RRAAnnggee--PPAADDddiinngg _n_u_m_b_e_r
               It is also possible to pad ranges to be whole aligned multiples
               of the given number.  For example
                      _i_n_p_u_t_-_f_i_l_e -fill 0xFF -within _i_n_p_u_t_-_f_i_l_e -range-pad 512
               will fill the _i_n_p_u_t_-_f_i_l_e so that it consists of whole  512-byte
               blocks, aligned on 512 byte boundaries.  Any large holes in the
               data will also be multiples of 512 bytes, though they may  have
               been shrunk as blocks before and after are padded.

               This  operator  has  the  same precedence as the explicit union
               operator.

       _a_d_d_r_e_s_s_-_r_a_n_g_e --IINNTTEERRsseecctt _a_d_d_r_e_s_s_-_r_a_n_g_e
               You can intersect two  address  ranges  to  produce  a  smaller
               address range.  The intersection operator has higher precedence
               than the implicit union operator (evaluated left to right).

       _a_d_d_r_e_s_s_-_r_a_n_g_e --UUNNIIoonn _a_d_d_r_e_s_s_-_r_a_n_g_e
               You can union two address ranges to produce  a  larger  address
               range.  The union operator has lower precedence than the inter-
               section operator (evaluated left to right).

       _a_d_d_r_e_s_s_-_r_a_n_g_e --DDIIFFffeerreennccee _a_d_d_r_e_s_s_-_r_a_n_g_e
               You can difference two address  ranges  to  produce  a  smaller
               address  range.   The result is the left hand range with all of
               the right hand range removed.  The difference operator has  the
               same  precedence as the implicit union operator (evaluated left
               to right).

       _a_d_d_r_e_s_s_-_r_a_n_g_e _a_d_d_r_e_s_s_-_r_a_n_g_e
               In addition, all of these methods may be used,  and  used  more
               than  once,  and  the  results will be combined (implicit union
               operator, same precedence as explicit union operator).

   CCaallccuullaatteedd VVaalluueess
       Most of the places above where a number is expected, you may supply one
       of the following:

       -- _v_a_l_u_e
               The  value of this expression is the negative of the expression
               argument.  Note the ssppaaccee between the minus sign and its  argu-
               ment: this space is mandatory.
                      srec_cat  in.srec  -offset  -  -minimum-addr  in.srec -o
                      out.srec
               This example shows how to move data to the base of memory.

       ( _v_a_l_u_e )
               You may use parentheses for grouping.  When using  parentheses,
               they  must each be a separate command line argument, they can't
               be within the text of the preceding or  following  option,  and
               you will need to quote them to get them past the shell, such as
               '(' and ')'.

       --MMIINNiimmuumm--AAddddrreessss _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n
               This inserts the minimum address of the specified  input  file.
               The input specification need not be just a file name, it may be
               anything any other input specification can be.

               See also the --oovveerr option for a discussion on  operator  prece-
               dence.

       --MMAAXXiimmuumm--AAddddrreessss _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n
               This  inserts  the maximum address of the specified input file,
               plus one.  The input specification need  not  be  just  a  file
               name, it may be anything any other input specification can be.

               See  also  the --oovveerr option for a discussion on operator prece-
               dence.

       --LLeennggtthh _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n
               This inserts the length of the address range in  the  specified
               input  file,  ignoring any holes.  The input specification need
               not be just a file name, it may be  anything  any  other  input
               specification can be.

               See  also  the --oovveerr option for a discussion on operator prece-
               dence.

       For example, the --OOVVEERR _i_n_p_u_t_-_s_p_e_c_i_f_i_c_a_t_i_o_n option can be thought of  as
       short-hand for ''(('' --mmiinn _f_i_l_e --mmaaxx _f_i_l_e ''))'', except that it is much eas-
       ier to type, and also more efficient.

       In addition, calculated values may optionally  be  rounded  in  one  of
       three ways:

       _v_a_l_u_e --RRoouunndd__DDoowwnn _n_u_m_b_e_r
               The  _v_a_l_u_e  is  rounded down to the the largest integer smaller
               than or equal to a whole multiple of the _n_u_m_b_e_r.

       _v_a_l_u_e --RRoouunndd__NNeeaarreesstt _n_u_m_b_e_r
               The _v_a_l_u_e is rounded to the the nearest whole multiple  of  the
               _n_u_m_b_e_r.

       _v_a_l_u_e --RRoouunndd__UUpp _n_u_m_b_e_r
               The _v_a_l_u_e is rounded up to the the smallest integer larger than
               or equal to a whole multiple of the _n_u_m_b_e_r.

       When using parentheses, they must each be a separate command line argu-
       ment,  they  can't  be  within  the  text of the preceding or following
       option, and you will need to quote them to get them past the shell,  as
       '(' and ')'.

CCOOPPYYRRIIGGHHTT
       _s_r_e_c___i_n_p_u_t version 1.64
       Copyright  (C)  1998,  1999,  2000, 2001, 2002, 2003, 2004, 2005, 2006,
       2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Peter Miller

       The _s_r_e_c___i_n_p_u_t program comes with ABSOLUTELY NO WARRANTY;  for  details
       use  the  '_s_r_e_c___i_n_p_u_t _-_V_E_R_S_i_o_n _L_i_c_e_n_s_e' command.  This is free software
       and you are welcome to redistribute it under  certain  conditions;  for
       details use the '_s_r_e_c___i_n_p_u_t _-_V_E_R_S_i_o_n _L_i_c_e_n_s_e' command.

MMAAIINNTTAAIINNEERR
       Scott Finneran   E-Mail:   scottfinneran@yahoo.com.au
       Peter Miller     E-Mail:   pmiller@opensource.org.au



Reference Manual                    SRecord                      srec_input(1)
